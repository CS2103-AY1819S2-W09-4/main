= Tan Wenjian - Project Portfolio
:site-section: AboutUs
:imagesDir: ../images
:stylesDir: ../stylesheets
:note-caption: :information_source:
:warning-caption: :warning:

== PROJECT: QuickDocs

== Introduction to QuickDocs

== Summary of contributions

=== Major Enhancements:

=== Minor Enhancements:

== Contributions to the User Guide

== Contributions to the Developer Guide

|===
|_For the developer guide, x_
|===

=== Administrative and Statistics Module
The administrative and statistics module currently consists of 2 commands: +

1. setting the consultation fee `setconsultfee` +
2. querying the statistics `statistics` +

This 2 commands makes use of the classes located in filepath `model\record`.

==== Consultation fee
The consultation fee of the clinic is stored as a BigDecimal in the StatisticsManager of QuickDocs, which is loaded from the
quickdocs.json file through the <<Design-Storage, storage>> component. The consultation fee is used for calculating
financial statistics for any ConsultationRecord objects.

==== Querying statistics
The statistics command is started through the command `stats START_MMYYYY [END_MMYYYY]`.
The two MMYYYY corresponds to a range of dates. The end range is optional,
and is defaulted to the start range by the StatisticsCommandParser if it does not exist. +

The start date is not allowed to be before January 2019, and the end date cannot be before the start date. Hence,
QuickDocs currently does not support adding old records before January 2019 due to the implementation of the
StatisticsManager. This will be explained in the section below. +
[NOTE]
MMYYYY is a string, e.g. "012019", which stands for January 2019. It is parsed by StatisticsCommandParser into a
YearMonth object. +

==== Statistics and Record - Current Implementation

The statistics class stores 6 types of information: +

1. Number of consultations +
2. Medicines prescribed +
3. Symptoms diagnosed +
4. Revenue +
5. Expenditure +
6. Profit +

Number of consultations is stored as an int, while the financial variables are stored using BigDecimals. The number of
medicines prescribed and symptoms diagnosed are stored by using a HashMap. +

[NOTE]
Implementation of additional statistics will be done through adding additional relevant variable fields.

The implementation of Statistics and Record has 3 parts: +

1. Creation of the Record +
2. Adding the Record +
3. Retrieving the Statistics +

===== 1. Creation of the Record
In order for the statistics to be keep tracked of, Record objects are used to retrieve information that the
StatisticsManager will make use of. The Record class is an abstract class that only has 1 abstract method,
`toStatistics(StatisticsManager sm)`, which will generate a Statistics object.
Each child class of Record is for a specific operation in QuickDocs, where the implementation
`toStatistics(StatisticsManager sm)` will generate a Statistics object that stores relevant information pertaining to
that specific operation. The StatisticsManager is passed in to retrieve the any variable that the Record might require
to calculate the statistics, e.g., ConsultationRecord requires the consultationFee variable in StatisticsManager.

Currently, there are only 2 child classes of Record, ConsultationRecord and MedicinePurchaseRecord. ConsultationRecords
are created when the a consultation session ends from the EndConsultCommand, while MedicinePurchaseRecord are created
when a medicine is purchased via the PurchaseMedicineCommand. The commands will create the Record, and call ModelManager's
`addRecord(record, clock)` function, which will then result in ModelManager calling StatisticsManager's `record(record, clock)`
function. The clock used is the system clock, to retrieve the current YearMonth of the Record created. The sequence diagram
below illustrates an example ConsultationRecord being created.

.Sequence diagram for sample ConsultationRecord creation
image::RecordCreationSD.png[width="800"]

===== 2. Adding the record
The StatisticsManager holds an ArrayList of MonthStatistics, where a MonthStatistics object contains the YearMonth, and
the Statistics object of that YearMonth. Each MonthStatistics object will be initialised with the zero Statistics object,
where all the variables are 0 or contains no elements (not null). The ArrayList starts with a MonthStatistics with the
YearMonth 2019 January, and every subsequent index will contain the MonthStatistics with the subsequent month, e.g.,
the 4th index contains the MonthStatistics with YearMonth 2019 May.

When the StatisticsManager adds a new Record by the `record(record, clock)` function, it will first retrieve the
YearMonth from the `clock` variable passed in. Next, it will update the size of the ArrayList by calling its own method
`updateListSize(clock)`, which is a wrapper for `updateListSize(YearMonth)`. Afterwards, StatisticsManager will find the
correct index of the MonthStatistics ArrayList to add the record in. In the current implementation, the record is not
actually stored. Instead, the record will be converted to a Statistics object which is then merged with the
MonthStatistics's own Statistics object. The MonthStatistics's Statistics object will then be reassigned with the newly
merged Statistics object. The sequence diagram below illustrates an example ConsultationRecord being added.

.Sequence diagram for adding a sample ConsultationRecord
image::SDForAddingRecords.png[width="800"]

===== 3. Retrieving the Statistics

When the StatisticsCommand queries for the statistics for a range
of months, Logic will call the ModelManager's `getStatistics(FROM_YEARMONTH, TO_YEARMONTH)`, which then calls
StatisticsManager's `getStatistics(FROM_YEARMONTH, TO_YEARMONTH)`. StatisticsManager will convert the YearMonth objects to
their respective indexes with the StatisticsManager's `getYearMonthIndex(YearMonth)` function.

StatisticsManager will then obtain the statistics for each of the queried months, and merge them together into a new
Statistics object. StatisticsManager will then return the Statistics back to the ModelManager, which would then return
it to the StatisticsCommand, which would then return the CommandResult with the statistics converted to a String to the
LogicManager.

==== Statistics and Record - Design considerations

1. The statistics are stored in months as the design only allows the doctor to query within a minimum timespan of 1 month.
Hence, it was decided that the statistics to be stored in months in a chronological order with an ArrayList for ease of
retrieval. +

2. Currently, as QuickDOcs is developed in 2019, and there are no plans to allow the doctor to add in past records,
the first index in the array of MonthStatistics is allocated to January 2019. Any MMYYYY value before 012019 will not be
allowed.

3. The MonthStatistics objects are stored in an ArrayList as it might be desirable for a MonthStatistics with the zero
statistics to exist (all variables 0 or no elements). Such a case might happen when the doctor goes on vacation for the
whole month. In addition, it would be easy to retrieve the MonthStatistics object of a specific MMYYYY by indexing.

==== Statistics and Record - Alternatives Considered
The following table lists out the alternatives designs considered for implementing the storage of the Records and Statistics.
[cols="1,2a,1, 1", options="header"]
|===
|Alternative |Description |Pros |Cons
// row 1
|*Storing of individual records for each month (Alternative chosen)*
|Individual records are stored within the MonthStatistics, along with the Statistics. When the Statistics for a
specific month is queried, update the latest statistics and return it.
|Individual records are kept, which could potentially be used for other calculations or features.
|Storing of individual records is extremely costly in terms of space
// row 2
|*Storing the merged statistics of all the records for each month*
|When a new record is added, it is coverted to a Statistics object which is then merged with the current Statistics object stored.
|Only one Statistics object needs to be stored, which saves a lot of storage space.
|The individual records are unable to be retrieved. However, the current implementation has no need to retrieve individual records.
|===
